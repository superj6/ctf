from pwn import *
from primefac import primefac
from more_itertools import set_partitions
from Crypto.Util.number import long_to_bytes
import math
import ast
import string

#init

#kek = process(['python3', 'chal.py'])
kek= remote('saturn.picoctf.net', 55524)

#vars

charset = string.ascii_letters + string.digits
charset = charset.encode()

e = 65537

log.info('e: {}'.format(e))

#exploit

kek.recvuntil('= ')
c = int(kek.recvline(keepends = False))
kek.recvuntil('= ')
d = int(kek.recvline(keepends = False))

log.info('c: {}'.format(c))
log.info('d: {}'.format(d))

ed1 = e * d - 1

log.info('ed1: {}'.format(ed1))

#phi = (p - 1) * (q - 1), e * d = 1 (mod phi), brute factors ed1 to get p and q

try:
    ed1facs = list(primefac(ed1))
except:
    ed1facs = ast.literal_eval(input("input ed1facs: "))

log.info("ed1facs: {}".format(ed1facs))

flag = b'rip'
for part in set_partitions(ed1facs, 3):
    for yeet in range(3):
        part[yeet], part[2] = part[2], part[yeet]

        p = math.prod(part[0]) + 1
        q = math.prod(part[1]) + 1
        n = p * q

        if c > n:
            continue

        m = pow(c, d, n)

        s = long_to_bytes(m)

        if len(s) == 16 and all(i in charset for i in flag):
            log.info('p: {}'.format(p))
            log.info('q: {}'.format(q))
            log.info('n: {}'.format(n))
            log.info('m: {}'.format(m))
            log.info('s: {}'.format(s))

            flag = s

        part[yeet], part[2] = part[2], part[yeet]


log.success('flag: {}'.format(flag))

kek.sendlineafter('> ', flag)
print(kek.recv(256))

#pray for flag

kek.interactive()
